---
title: "Extending R with C++"
subtitle: "A brief introduction to Rcpp and Armadillo"
author: "Lionel Voirol & Samuel Orso"
date: "3 May 2021"
output:
  xaringan::moon_reader:
    css: ["default", "assets/sydney-fonts.css", "assets/sydney.css"]
    self_contained: false # if true, fonts will be stored locally
    seal: true # show a title slide with YAML information
    includes:
      in_header: "assets/mathjax-equation-numbers.html"
    nature:
      beforeInit: ["assets/remark-zoom.js"]
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9' # alternatives '16:9' or '4:3' or others e.g. 13:9
      navigation:
        scroll: false # disable slide transitions by scrolling
---


@Sam for an introduction to xaringan, see

https://spcanelon.github.io/xaringan-basics-and-beyond/

and

https://github.com/garthtarr/sydney_xaringan

also, check about [infinite moon reader](https://yihui.org/en/2019/02/ultimate-inf-mr/) for development

---


# Objectives
```{r, load_refs, echo=FALSE, cache=FALSE, warning = F, message=F}
library(RefManageR)
BibOptions(check.entries = FALSE, 
           bib.style = "authoryear", 
           cite.style = 'authoryear', 
           style = "markdown",
           hyperlink = FALSE, 
           dashed = FALSE)
myBib <- ReadBib("assets/example.bib", check = FALSE)
library(Rcpp)
library(RcppArmadillo)
```

- Understand how to measure performance in `R` using profiling and timing tools.

- Understand how to compile `Rcpp` code and use it in `R`.

- Get an understanding of the `Rcpp` basic syntax.

- Understand how to use `C++` linear algebra libraries for scientific computing (`Armadillo`)


&nbsp;

```{r echo=FALSE, fig.align='center', out.width=350, out.height=160}
knitr::include_graphics("assets/thelogo.png")
```

---

# Why using `C++` in `R`: Motivations

When working with complex computations in `R`, it is often the case that `R` is simply not fast enough. In such cases, it is interesting to identify where are the bottleneck in a given code rewrite these chunks of code in a lower-level language.

`C++` is a general-purpose programming language developed initially as an extension of the `C` language that included classes. As opposed to `R`, `C++` is a compiled language. `C++` is considered as a benchmark for speed as it is faster than most lower level language such as `Fortran` or `C`.

Examples of ideal situations where to use `Rcpp` are:

- Loop operations
- Recursive functions
- Complex operations on Big Data
- Complex algorithms that need advanced data structures and algorithms


---
# Using `C++` in `R` 

`Rcpp` is an `R` package that makes it very easy to connect `C++` code to `R`. Written by Dirk Eddelbuettel and Romain Francois, `Rcpp` let you compile and use `C++` functions directly in `R`.

You can install `Rcpp` with
```{r, eval =F}
install.packages("Rcpp")
```

Note that you will also need to install `Rtools` to compile `C++` code. To do so, follow the instructions [here](https://cran.r-project.org/bin/macosx/tools/) if you have a Mac or [here](https://cran.r-project.org/bin/windows/Rtools/) for a Windows system. 

If you are on Linux, depending on your distro, you can use:
```{bash, eval =F}
# RHEL/CentOS
sudo yum update
sudo yum install R
# Ubuntu
sudo apt-get update
sudo apt-get install r-base r-base-dev
```




---
# Profiling `R` code 

When working on the efficiency of an `R` code it is important to identify which part of the code are the most time consuming. Indeed, rewriting `R` code in `C++` is a time-consuming step and rewriting a chunk of code that only represent a small fraction of the total computing time is not efficient.

You can profile `R` code with the use of the packages `Rprof` and `profvis` available with 
```{r, eval = F}
install.packages("profvis")
```

The synthax to perform a code profiling analysis is then
```{r, eval =F}
profvis({
  R sequence of execution to profile
})
```

Find examples and instructions [here](https://rstudio.github.io/profvis/).


---
# Measuring computation time in `R`

There exists various ways to measure computation time in `R`. We recommend using the `microbenchmark` package available with
```{r, eval =F}
install.packages("microbenchmark")
```

Using the function `microbenchmark` of this package, one can obtain an estimate of the computation time of an expression by evaluating it a large number of time.

---
# Measuring computation time in `R` (2)

For example let us consider benchmarking a simple `R` functions:

```{r}
library(microbenchmark)
f1 = function(x){sum(exp(x))}
microbenchmark::microbenchmark(f1)
```

These results summarize how long each query took: the minimum (`min`), lower and upper quartiles (`lq` and `uq`, respectively) and the mean, median and maximum, for each of the number of evaluations (`neval`, with the default value of 100 used in this case). `cld` reports the relative rank of each row in the form of 'compact letter display'.





---
# Optimizing `R` code

Before implementing a given code chunk that constitutes a bottleneck in `C++`, one should try to write the `R` code as efficiently as possible. There exists multiple way to improve the performance of an `R` code. General advice are for example to declare type and length of data structure explicitly rather then appending to existing data structure and to use efficiently implemented `R` functions when possible.

`R` is know to be particularly inefficient with iterative loop such as `for` and `while` loop. When computing operations on specific data structures, the `apply()` family of functions proposes a higher level interface to manipulate and execute operations on slices of data structure in a repetitive way rather than by explicit `for` loops. Note however, that `apply()`-type functions are not necessarily faster than `for` loop, but they provide an easy interface for repetitive computations on specific data structures and increase code readability.

Find a tutorial on the `apply()` family of functions [here](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family).


---
# Optimizing `R` code: Illustration
Let us consider a simple example where we want to construct a vector of length $n$.
<!-- Let us consider a simple example where we consider applying the function $$f: \mathbb{R}^p \rightarrow \mathbb{R} = n^{-1}\sum_{i=1}^n X_i$$ to each element of a list. -->

```{r, echo = F}
options(scipen =999)
```



.pull-left[

.scroll-box-5[
```{r, eval =T}
method1 = function(n) {
  vec = NULL # Or vec = c()
  for (i in seq_len(n))
    vec = c(vec, i)
  vec
}
```
]]
.pull-right[

.scroll-box-5[
```{r, eval =T}
method2 = function(n) {
  vec = vector(mode = "numeric", length = n) ##<
  for (i in seq_len(n))
    vec[i] = i
  vec
}
```
]]


```{r}
method3 = function(n) seq_len(n)
microbenchmark(times = 100, unit = "s",  method1(n), method2(n), method3(n))
```




---
# A brief introduction to `C++` and `Rcpp`

<blockquote>

Rcpp is a package that enables you to implement R functions in C++. It is easy to use even without deep knowledge of C++, because it is implemented so as to write your C++ code in a style similar to R. And Rcpp does not sacrifice execution speed for the ease of use, anyone can get high performance outcome.
.right[-- <cite>Rcpp for everyone</cite>]
</blockquote>

`Rcpp` provide three ways to embed `C++` code in `R`.

- `sourceCpp()` 

- `cppFunction()` 

- `evalCpp()` 

---
# Embedding `Rcpp` code in `R`
`sourceCpp()` let you source and compile a `.cpp` file inside of an `R` environment.
```{r, eval =F}
sourceCpp("cpp_file.cpp")
```


`cppFunction` let you write an `Rcpp` function directly inside of an `R` environment, for example:
```{Rcpp, eval =F}
cppFunction('int add(int x, int y, int z) {
  int sum = x + y + z;
  return sum;
}')
```
```{r}

```


`evalCpp()` let you evaluate a single `C++` statement inside of an `R` environment.
```{R, eval =F}
evalCpp('std::numeric_limits<double>::max()')
```


For this workshop, we will mostly consider using `sourceCpp()` and writing `C++` code in an specific `.cpp` file as this provide various advantages that we will cover.

---
# Header of a `.cpp` file 
```{Rcpp, eval =F}
#include<Rcpp.h> #<<
using namespace Rcpp; #<<

// [[Rcpp::export]]
RETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){

    //do something

    return RETURN_VALUE;
}
```

`#include<Rcpp.h> ` enables you to use classes and functions defined by the `Rcpp` package.
`using namespace Rcpp;` specify the namespace. One could omit this argument in the header and prefix all functions and objects defined by `Rcpp` with `Rcpp::`.


---
# `C++` and `Rcpp` synthax (simple examples)

`Rcpp` provides a high-level synthax for declaring `C++` functions easily. Here are some example comparing `R` and `Rcpp` synthax.

.pull-left[
### `R` code

.scroll-box-14[
```{r, eval =F}

```
]]
.pull-right[
### `C++` code

.scroll-box-14[
```{Rcpp, eval =F}

```
]]

---

---
# `Rcpp sugar`

The `Rcpp` library provide a variety of `R`-style 





---

# Including support for `Armadillo`  .pull-right-narrow[![](assets/armadillo_logo2.png)]


In addition to the functions provided by `Rcpp` and the `C++` standard library `std::`, one can also make use of high quality `C++` linear algebra libraries such as `Armadillo` and `Eigen` with respectively `R` package `RcppArmadillo` and `RcppEigen`. We present here how to use the `Armadillo` library. Once `RcppArmadillo` has been installed with 


```{r, eval =F}
install.packages("RcppArmadillo")
```

One can source a `.cpp` file that make use of `Armadillo` by specifying the following arguments in the header of the `.cpp` file:

```{Rcpp, eval =F}
#include <RcppArmadillo.h>  #<<
// [[Rcpp::depends(RcppArmadillo)]] #<<
using namespace Rcpp;  #<<
```


`[[Rcpp::depends(RcppArmadillo)]]` ensures that `sourceCpp()` can compile and load the `RcppArmadillo` headers.


---
# How `RcppArmadillo` works




---
# Use case: Haar Wavelet Variance

We here consider a real case application of transferring `R` code in `C++` code.

For this example, we will conside the Haar Wavelet Variance.

This statistical quantity is used in the context of inference for latent 

- What is the haar wavelet variance

- What is it used for

- Why we consider this example

- Explain computation algorithm

---
# Use case: The Haar Wavelet Variance 

.pull-left[
### `R` code

.scroll-box-14[
```{r, eval =F}
wvar_r = function(Xt){
  tsl = length(Xt)
  #define J
  J = log(tsl, 2) %>% floor()
  #create list to store elements
  haar_coeff_list = list()
  all_j =   J %>% seq()
  #define all scales
  scales = 2^all_j
  for(i_j in all_j){
    i_scale = scales[i_j]
    length_haar_transfo = tsl - 2^i_j + 1
    
    #define positive and negative yt
    coef_length = seq(length_haar_transfo)
    coef_scale_i = vector(length =length_haar_transfo, mode = "numeric")
    for(cl in coef_length){
      #define all position
      pos_scale_i = seq(cl, i_scale+cl-1)
      #define t/2 for scale j
      mid_id = length(pos_scale_i)/2
      #define left and right position
      neg_id = pos_scale_i[1:mid_id] 
      pos_id =  tail(pos_scale_i,length(pos_scale_i)/2)
      #calculate haar coefficient define as the weighted mean where weight equal -1, 1
      xt_neg = Xt[neg_id] * -1
      xt_pos = Xt[pos_id]
      xt_weighted = c(xt_neg, xt_pos)
      coef_scale_i[cl] = mean(xt_weighted)
    }
    #append to growing vector
    haar_coeff_list[[i_j]] = coef_scale_i
  }
  #calculate wavelet variance
  wvariance = vector(mode = "numeric", length = length(all_j))
  for(i in seq(length(all_j))){
    # wvariance[i] = var(haar_coeff_list[[i]])*(length(haar_coeff_list[[i]])-1)/length(haar_coeff_list[[i]])
    # wvariance[i] = var(haar_coeff_list[[i]])
    haar_coef = haar_coeff_list[[i]]
    wvariance[i] = t(haar_coef) %*% haar_coef / length(haar_coef)
  }
  #return haar coefficients and wvariance
  return(wvariance)
}
```
]]
.pull-right[
### `C++` code

.scroll-box-14[
```{Rcpp, eval =F}
// [[Rcpp::export]]
arma::colvec wvar_cpp(arma::vec Xt) {
  int tsl = Xt.n_elem;
  // define J
  int J = floor(log(tsl) / log(2));
  List haar_coef_list = List::create();
  IntegerVector all_j = seq_len( J );
  for(int i_j = 1; i_j <= J; i_j++) {
    // Define scale tau
    double i_scale = pow(2,i_j);
    int length_haar_transfo = tsl - i_scale + 1;
    //  create empty vector to fill
    NumericVector coef_scale_i (length_haar_transfo);
    for(int cl = 1; cl <= length_haar_transfo; cl++) {
      arma::vec pos_scale_i = arma::linspace(cl-1, i_scale +cl -2,  i_scale );
      //  define negative, positive and mid id
      int mid_id = pos_scale_i.n_elem/2 ;
      arma::vec pos_id = pos_scale_i.tail(mid_id);
      arma::vec neg_id = pos_scale_i.head(mid_id);
      // Convert to position to arma uvec
      arma::uvec pos_id_2 = arma::conv_to<arma::uvec>::from(pos_id);
      arma::uvec neg_id_2 = arma::conv_to<arma::uvec>::from(neg_id);
      // extract from vector
      arma::vec xt_neg =  Xt.elem(neg_id_2) * -1;
      arma::vec xt_pos =  Xt.elem(pos_id_2) ;
      //  compute coefficient
      arma::vec xt_weighted = join_cols(xt_neg, xt_pos);
      coef_scale_i(cl-1) = mean(xt_weighted);
    }
    // append to rcpp list
    haar_coef_list.push_back(coef_scale_i);
    }
  //  create empty vector for wavelet variance
  arma::colvec wvariance (J);
  // populate wvariance with wavelet variance 
  // computed on coefficient for each scale j
  for(int i = 0; i < J; i++) {
    arma::vec haar_coef = haar_coef_list[i];
    wvariance.row(i) = haar_coef.t() * haar_coef / haar_coef.n_elem;
  }
  return wvariance;
  
}

```
]]


---
# Use case: The Haar Wavelet Variance 
## Performance gain





---

# Parallelisation with openMPI


---

# To go further (Ressources)

- [Advanced R](https://adv-r.hadley.nz/)

- [Rcpp for everyone](https://teuder.github.io/rcpp4everyone_en/)

- [Seamless R and C++ Integration with Rcpp](https://www.springer.com/gp/book/9781461468677)

- [Efficient R programming](https://csgillespie.github.io/efficientR/)

- [Armadillo documentation](http://arma.sourceforge.net/docs.html)
---
class: sydney-blue, center, middle


# Thanks!
## Any questions?

.pull-down[
<a href="mailto:garth.tarr@sydney.edu.au">
.white[`r icons::fontawesome("paper-plane")` Lionel.Voirol@unige.ch]
</a>



<a href="http://github.com/garthtarr">
.white[`r icons::fontawesome("github")` @lionelvoirol]
</a>


<a href="mailto:garth.tarr@sydney.edu.au">
.white[`r icons::fontawesome("paper-plane")` Samuel.Orso@unige.ch]
</a>



<a href="http://github.com/garthtarr">
.white[`r icons::fontawesome("github")` @samorso]
</a>


<a href="https://github.com/SMAC-Group/r_lunch_rcpp">
.white[`r icons::fontawesome("images")` SMAC-Group/r_lunch_rcpp]
</a>

]




